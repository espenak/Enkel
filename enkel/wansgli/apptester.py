# This file is part of the Enkel web programming library.
#
# Copyright (C) 2007 Espen Angell Kristiansen (espen@wsgi.net)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

""" Simple WSGI app testing without the need of a server.


@var MP_CONTENT_TYPE: Default content-type for files in multipart
		requests created by L{encode_multipart}.
@var CT_FORM_ENCODED: content-type used when a normal POST request
		is created in L{parse_params}.
@var CT_MULTIPART_ENCODED: content-type used when a multipart POST
		request is created in L{parse_params}.
"""


from urllib import quote_plus
from cStringIO import StringIO
from email.Parser import Parser

from apprunner import run_app, Response
from env import url_to_environ


MP_CONTENT_TYPE = "application/octet-stream"
CT_FORM_ENCODED = "application/x-www-form-urlencoded"
CT_MULTIPART_ENCODED = "multipart/form-data"


def encode_query(params):
	""" Encode params the same format as the one generated by browsers
	when sending non-multipart form requests to a server.

	@param params: Same as params parameter to L{AppTester.__init__}.
	@return: the encoded version of params.
	"""
	q = []
	for key, value in params:
		q.append("%s=%s" % (key, quote_plus(value)))
	return "&".join(q)


def encode_multipart(params):
	""" Encode params in the format specified in
	U{rfc1867<http://www.ietf.org/rfc/rfc1867.txt>}

	WARNING
	=======
		This code uses several inefficient methods to
		ensure that the result is error-free. The most time
		consuming of these is that the entire result is
		scanned to make sure the boundary is unique.

	@param params: Same as params parameter to L{AppTester.__init__}.
	@return: (boundary, body) pair. "boundary" is the boundary
			used to separate the blocks in the body. "body"
			is the encoded version of "params". The boundary
			is generated to guarantee that it does not occure
			within any of the param-blocks.
	"""
	l = []
	sep = Response.SEP

	# fill "l" with one node per param
	for param in params:
		name = param[0]
		value = param[1]
		buf = [
			"content-disposition: form-data; name=\"%(name)s\"",
			"",
			value,
			""
		]
		if len(param) > 2:
			filename = param[2]
			buf[0] += "; filename=\"%(filename)s\""
			buf.insert(1, "content-type: %(content_type)s")

			content_type = MP_CONTENT_TYPE
			if len(param) > 3:
				content_type = param[3]
		l.append(sep.join(buf) % vars())

	# create unique boundary
	ok = False
	n = 1000
	while(not ok):
		ok = True
		boundary = "%d" % n
		for buf in l:
			if buf.count(boundary) > 0:
				ok = False
				break
		n += 1

	# create body
	b = "--" + boundary + sep
	return boundary, "%s%s--%s--%s" % (b, b.join(l), boundary, sep)



def parse_params(env, params):
	"""
	If env["REQUEST_METHOD"] is POST, L{env} nodes with key "CONTENT_TYPE",
	"CONTENT_LENGTH" and "wsgi.input" will be added/overwritten.

	If env["REQUEST_METHOD"] is GET, the encoded parameters will be appended
	to "QUERY_STRING" in L{env} .

	WARNING: The method changes "env".
	@param env: A dictionary (WSGI environ dict).
	@return: The boundary used if the request is multipart, or None if not.
	"""
	method = env["REQUEST_METHOD"]

	# check if if request is multipart
	multipart = False
	for param in params:
		if not len(param) in (2, 3, 4):
			raise ValueError("params must be list of 2-4 values")
		if len(param) > 2:
			if method == "GET":
				raise ValueError("GET requests cannot have file-params.")
			multipart = True


	# add to env
	boundary = None
	if multipart:
		boundary, query = encode_multipart(params)
		env["CONTENT_TYPE"] = CT_MULTIPART_ENCODED
	else:
		query = encode_query(params)
		if method == "GET":
			env["QUERY_STRING"] = \
					env.get("QUERY_STRING", "") + query
			return None
		else:
			env["CONTENT_TYPE"] = CT_FORM_ENCODED
	env["CONTENT_LENGTH"] = len(query)
	env["wsgi.input"] = StringIO(query)
	return boundary


class AppTester(object):
	r""" WSGI app tester.


	Shared setup
	============
		>>> def my_app(environ, start_response):
		... 	start_response("200 OK", [("Content-type", "text/plain")])
		... 	if "raise exception" in environ:
		... 		raise Exception("something is wrong")
		... 	if environ["REQUEST_METHOD"] == "POST":
		... 		return ["post request recieved"]
		... 	else:
		... 		return ["a get request: %s" % environ["QUERY_STRING"]]

		>>> params = [
		... 	("name", "john"),
		... 	("id", "2345"),
		... 	("age", "20")
		... ]


	Using it to test an app
	=======================
		>>> t = AppTester(my_app, params)
		>>> r = t.run_get()

		>>> r.server_protocol
		'HTTP/1.0'
		>>> r.status
		'200 OK'
		>>> r.raw_headers
		'content-type: text/plain'
		>>> r.body
		'a get request: name=john&id=2345&age=20'

		>>> assert(r.body_startswith("a get"))
		>>> assert(r.body_endswith("20"))
		>>> assert(r.body_contains("request"))
		>>> assert(r.body_ncontains("e", 5))
		>>> r.headers["content-type"]
		'text/plain'



	Different request-methods
	=========================

		GET request
		-----------

		>>> t = AppTester(my_app, params)
		>>> r = t.run_get()
		>>> r.env.get("QUERY_STRING")
		'name=john&id=2345&age=20'


		Post request
		------------

		>>> r = t.run_post()
		>>> r.env["wsgi.input"].read()
		'name=john&id=2345&age=20'


		Multipart post request
		----------------------

		>>> t.params = [
		... 	("somevar", "jeje"),
		... 	("me", "i don't have a picure of myself;)", "me.jpg", "image/jpeg"),
		... 	("myfile", "this is a test", "test.txt")
		... ]
		>>> r = t.run_post()
		>>> r.boundary
		'1000'
		>>> b = r.env["wsgi.input"].read()
		>>> l = b.split("--" + r.boundary)
		>>> l[2]
		'\r\ncontent-disposition: form-data; name="me"; filename="me.jpg"\r\ncontent-type: image/jpeg\r\n\r\ni don\'t have a picure of myself;)\r\n'


	Adding to env
	=============
		>>> t = AppTester(my_app, params)
		>>> t.set_env("raise exception", "yes")
		>>> r = t.run_get()
		Traceback (most recent call last):
		...
		Exception: something is wrong


	Manual setup
	============
		Until now we have used L{run_get} and L{run_post} to
		run the apps. These methods adds information to the
		the WSGI environment variable used to run the app,
		and are usually what we want to use. But sometimes
		we might wish to setup the environment ourselves.
		In these cases, use L{run}.

		This example does what run_get does, manually.

		>>> t = AppTester(my_app)
		>>> t.set_env("QUERY_STRING", "name=john&age=68")
		>>> t.set_env("REQUEST_METHOD", "GET")
		>>> t.run().body
		'a get request: name=john&age=68'


	@ivar env: A WSGI environ dict. Can/should be modified.
	@ivar app: The app specified as a parameter to L{__init__}.
	@ivar params: A list of parameters as described in L{__init__}.
	"""

	def __init__(self, app, params=[], url=None):
		""" Initialize apptester.

		Set instance variable L{env} and and add the following
		entries:
			- SERVER_PROTOCOL: "HTTP/1.0"

		@param app: A WSGI app.
		@param params: List of tuples of the form
				(name, value[, filename[, content-type]). Only POST
				request can have parameters with filename and
				content-type. If filename is given the request becomes
				a multipart request. content-type defaults to
				L{MP_CONTENT_TYPE}
		@param url: The url to pretend the app is listening on.
				You should see L{env.url_to_environ} about what is
				added to "env". If None, "env" is not changed.
		"""
		self.env = dict(SERVER_PROTOCOL = "HTTP/1.0")
		self.params = list(params)
		self.app = app
		if url:
			url_to_environ(self.env, url)


	def set_env(self, key, value):
		""" Add to L{env}. """
		self.env[key] = value

	def _run(self, env, debug):
		buf = StringIO()
		run_app(self.app, Response(buf, env, debug))
		return ResponseTester(env, buf.getvalue())


	def run(self, debug=True):
		""" Run the L{app} using L{apprunner.run_app}.

		@note: L{env} is not changed, but it is copied.

		@param debug: See L{apprunner.Response.__init__}
		@return: A L{ResponseTester} object initalized with the
				information the app responded with.
		"""
		return self._run(self.env.copy(), debug)


	def _run_method(self, method, debug):
		env = self.env.copy()
		env["REQUEST_METHOD"] = method
		boundary = parse_params(env, self.params)
		r = self._run(env, debug)
		r.boundary = boundary
		return r

	def run_get(self, debug=True):
		return self._run_method("GET", debug)

	def run_post(self, debug=True):
		return self._run_method("POST", debug)


class ResponseTester(object):
	""" WSGI app response tester.
	
	@see: L{AppTester} for examples.

	@ivar env: The WSGI environ dict which was sent to the app.
	@ivar raw_response: The entire response from app.
	@ivar server_protocol: The server protocol used to run app.
	@ivar status: The status message from app.
	@ivar raw_headers: The raw headers from app.
	@ivar body: The body from app.
	@ivar headers: A email.Message.Message object containing
			the headers from app.
	@ivar boundary: When using L{AppTester.run_post} and request is
			multipart, this contains the boundary returned by
			L{encode_multipart}.
	"""
	def __init__(self, env, raw_response):
		self.env = env
		self.boundary = None
		h, self.body = raw_response.split(
				Response.SEP + Response.SEP, 1)
		s, self.raw_headers = h.split(Response.SEP, 1)

		self.server_protocol, self.status = s.split(None, 1)
		self.headers = Parser().parsestr(self.raw_headers, headersonly=True)

	def body_startswith(self, string):
		""" Check if body starts with "string".
		@return: True if it does and False if not.
		"""
		return self.body.startswith(string)

	def body_endswith(self, string):
		""" Check if body ends with "string".
		@return: True if it does and False if not.
		"""
		return self.body.endswith(string)

	def body_contains(self, string):
		""" Check if body contains the "string".
		@return: True if it does and False if not.
		"""
		return self.body.count(string) > 0

	def body_ncontains(self, string, count=1):
		""" Check if body contains "count" occurrences of "string".
		@return: True if it does and False if not.
		"""
		return self.body.count(string) == count



def suite():
	import doctest
	return doctest.DocTestSuite()

if __name__ == "__main__":
	from testhelpers import run_suite
	run_suite(suite())

